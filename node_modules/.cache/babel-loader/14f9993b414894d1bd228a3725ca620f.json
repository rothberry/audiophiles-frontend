{"ast":null,"code":"import { createElement, Component } from 'react';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty = _defineProperty;\nvar defineProperty$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: defineProperty,\n  __moduleExports: defineProperty\n});\nvar defineProperty$2 = defineProperty$1 && defineProperty || defineProperty$1;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty$2(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nvar objectSpread = _objectSpread;\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar _extends_1 = createCommonjsModule(function (module) {\n  function _extends() {\n    module.exports = _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  module.exports = _extends;\n});\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;\nvar objectWithoutPropertiesLoose$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: objectWithoutPropertiesLoose,\n  __moduleExports: objectWithoutPropertiesLoose\n});\nvar objectWithoutPropertiesLoose$2 = objectWithoutPropertiesLoose$1 && objectWithoutPropertiesLoose || objectWithoutPropertiesLoose$1;\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose$2(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar objectWithoutProperties = _objectWithoutProperties;\nvar runtime = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  !function (global) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    var runtime = global.regeneratorRuntime;\n\n    if (runtime) {\n      {\n        // If regeneratorRuntime is defined globally and we're in a module,\n        // make the exports object identical to regeneratorRuntime.\n        module.exports = runtime;\n      } // Don't bother evaluating the rest of this file if the runtime was\n      // already defined globally.\n\n      return;\n    } // Define the runtime globally (as expected by generated code) as either\n    // module.exports (if we're in a module) or a new, empty object.\n\n\n    runtime = global.regeneratorRuntime = module.exports;\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        prototype[method] = function (arg) {\n          return this._invoke(method, arg);\n        };\n      });\n    }\n\n    runtime.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    runtime.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n\n        if (!(toStringTagSymbol in genFun)) {\n          genFun[toStringTagSymbol] = \"GeneratorFunction\";\n        }\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    runtime.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return Promise.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return Promise.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new Promise(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n\n    runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    runtime.async = function (innerFn, outerFn, self, tryLocsList) {\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n      return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          if (delegate.iterator.return) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    runtime.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    runtime.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function (skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined;\n            }\n          }\n        }\n      },\n      stop: function () {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function (exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function (type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function (record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function (finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function (tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined;\n        }\n\n        return ContinueSentinel;\n      }\n    };\n  }( // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  function () {\n    return this || typeof self === \"object\" && self;\n  }() || Function(\"return this\")());\n});\nvar runtime$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: runtime,\n  __moduleExports: runtime\n});\nvar require$$0 = runtime$1 && runtime || runtime$1;\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\n\nvar g = function () {\n  return this || typeof self === \"object\" && self;\n}() || Function(\"return this\")(); // Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\n\n\nvar hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0; // Save the old regeneratorRuntime in case it needs to be restored later.\n\nvar oldRuntime = hadRuntime && g.regeneratorRuntime; // Force reevalutation of runtime.js.\n\ng.regeneratorRuntime = undefined;\nvar runtimeModule = require$$0;\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch (e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\nvar runtimeModule$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: runtimeModule,\n  __moduleExports: runtimeModule\n});\nvar require$$0$1 = runtimeModule$1 && runtimeModule || runtimeModule$1;\nvar regenerator = require$$0$1;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar asyncToGenerator = _asyncToGenerator;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n\nvar _typeof_1 = createCommonjsModule(function (module) {\n  function _typeof2(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof2 = function _typeof2(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof2 = function _typeof2(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof2(obj);\n  }\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n      module.exports = _typeof = function _typeof(obj) {\n        return _typeof2(obj);\n      };\n    } else {\n      module.exports = _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  module.exports = _typeof;\n});\n\nvar _typeof =\n/*#__PURE__*/\nObject.freeze({\n  default: _typeof_1,\n  __moduleExports: _typeof_1\n});\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar assertThisInitialized = _assertThisInitialized;\nvar assertThisInitialized$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: assertThisInitialized,\n  __moduleExports: assertThisInitialized\n});\n\nvar _typeof$1 = _typeof && _typeof_1 || _typeof;\n\nvar assertThisInitialized$2 = assertThisInitialized$1 && assertThisInitialized || assertThisInitialized$1;\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof$1(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized$2(self);\n}\n\nvar possibleConstructorReturn = _possibleConstructorReturn;\nvar getPrototypeOf = createCommonjsModule(function (module) {\n  function _getPrototypeOf(o) {\n    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  module.exports = _getPrototypeOf;\n});\nvar setPrototypeOf = createCommonjsModule(function (module) {\n  function _setPrototypeOf(o, p) {\n    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  module.exports = _setPrototypeOf;\n});\nvar setPrototypeOf$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: setPrototypeOf,\n  __moduleExports: setPrototypeOf\n});\nvar setPrototypeOf$2 = setPrototypeOf$1 && setPrototypeOf || setPrototypeOf$1;\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf$2(subClass, superClass);\n}\n\nvar inherits = _inherits;\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\nvar arrayWithoutHoles$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: arrayWithoutHoles,\n  __moduleExports: arrayWithoutHoles\n});\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\nvar iterableToArray$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: iterableToArray,\n  __moduleExports: iterableToArray\n});\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\nvar nonIterableSpread$1 =\n/*#__PURE__*/\nObject.freeze({\n  default: nonIterableSpread,\n  __moduleExports: nonIterableSpread\n});\nvar arrayWithoutHoles$2 = arrayWithoutHoles$1 && arrayWithoutHoles || arrayWithoutHoles$1;\nvar iterableToArray$2 = iterableToArray$1 && iterableToArray || iterableToArray$1;\nvar nonIterableSpread$2 = nonIterableSpread$1 && nonIterableSpread || nonIterableSpread$1;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles$2(arr) || iterableToArray$2(arr) || nonIterableSpread$2();\n}\n\nvar toConsumableArray = _toConsumableArray;\nvar activestorage = createCommonjsModule(function (module, exports) {\n  !function (t, e) {\n    module.exports = e();\n  }(commonjsGlobal, function () {\n    return function (t) {\n      function e(n) {\n        if (r[n]) return r[n].exports;\n        var i = r[n] = {\n          i: n,\n          l: !1,\n          exports: {}\n        };\n        return t[n].call(i.exports, i, i.exports, e), i.l = !0, i.exports;\n      }\n\n      var r = {};\n      return e.m = t, e.c = r, e.d = function (t, r, n) {\n        e.o(t, r) || Object.defineProperty(t, r, {\n          configurable: !1,\n          enumerable: !0,\n          get: n\n        });\n      }, e.n = function (t) {\n        var r = t && t.__esModule ? function () {\n          return t.default;\n        } : function () {\n          return t;\n        };\n        return e.d(r, \"a\", r), r;\n      }, e.o = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }, e.p = \"\", e(e.s = 2);\n    }([function (t, e, r) {\n      function n(t) {\n        var e = a(document.head, 'meta[name=\"' + t + '\"]');\n        if (e) return e.getAttribute(\"content\");\n      }\n\n      function i(t, e) {\n        return \"string\" == typeof t && (e = t, t = document), o(t.querySelectorAll(e));\n      }\n\n      function a(t, e) {\n        return \"string\" == typeof t && (e = t, t = document), t.querySelector(e);\n      }\n\n      function u(t, e) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n            n = t.disabled,\n            i = r.bubbles,\n            a = r.cancelable,\n            u = r.detail,\n            o = document.createEvent(\"Event\");\n        o.initEvent(e, i || !0, a || !0), o.detail = u || {};\n\n        try {\n          t.disabled = !1, t.dispatchEvent(o);\n        } finally {\n          t.disabled = n;\n        }\n\n        return o;\n      }\n\n      function o(t) {\n        return Array.isArray(t) ? t : Array.from ? Array.from(t) : [].slice.call(t);\n      }\n\n      e.d = n, e.c = i, e.b = a, e.a = u, e.e = o;\n    }, function (t, e, r) {\n      function n(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      function i(t, e) {\n        if (t && \"function\" == typeof t[e]) {\n          for (var r = arguments.length, n = Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++) n[i - 2] = arguments[i];\n\n          return t[e].apply(t, n);\n        }\n      }\n\n      r.d(e, \"a\", function () {\n        return c;\n      });\n\n      var a = r(6),\n          u = r(8),\n          o = r(9),\n          s = function () {\n        function t(t, e) {\n          for (var r = 0; r < e.length; r++) {\n            var n = e[r];\n            n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n          }\n        }\n\n        return function (e, r, n) {\n          return r && t(e.prototype, r), n && t(e, n), e;\n        };\n      }(),\n          f = 0,\n          c = function () {\n        function t(e, r, i) {\n          n(this, t), this.id = ++f, this.file = e, this.url = r, this.delegate = i;\n        }\n\n        return s(t, [{\n          key: \"create\",\n          value: function (t) {\n            var e = this;\n            a.a.create(this.file, function (r, n) {\n              if (r) return void t(r);\n              var a = new u.a(e.file, n, e.url);\n              i(e.delegate, \"directUploadWillCreateBlobWithXHR\", a.xhr), a.create(function (r) {\n                if (r) t(r);else {\n                  var n = new o.a(a);\n                  i(e.delegate, \"directUploadWillStoreFileWithXHR\", n.xhr), n.create(function (e) {\n                    e ? t(e) : t(null, a.toJSON());\n                  });\n                }\n              });\n            });\n          }\n        }]), t;\n      }();\n    }, function (t, e, r) {\n      function n() {\n        window.ActiveStorage && Object(i.a)();\n      }\n\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n      var i = r(3),\n          a = r(1);\n      r.d(e, \"start\", function () {\n        return i.a;\n      }), r.d(e, \"DirectUpload\", function () {\n        return a.a;\n      }), setTimeout(n, 1);\n    }, function (t, e, r) {\n      function n() {\n        d || (d = !0, document.addEventListener(\"submit\", i), document.addEventListener(\"ajax:before\", a));\n      }\n\n      function i(t) {\n        u(t);\n      }\n\n      function a(t) {\n        \"FORM\" == t.target.tagName && u(t);\n      }\n\n      function u(t) {\n        var e = t.target;\n        if (e.hasAttribute(l)) return void t.preventDefault();\n        var r = new c.a(e),\n            n = r.inputs;\n        n.length && (t.preventDefault(), e.setAttribute(l, \"\"), n.forEach(s), r.start(function (t) {\n          e.removeAttribute(l), t ? n.forEach(f) : o(e);\n        }));\n      }\n\n      function o(t) {\n        var e = Object(h.b)(t, \"input[type=submit]\");\n\n        if (e) {\n          var r = e,\n              n = r.disabled;\n          e.disabled = !1, e.focus(), e.click(), e.disabled = n;\n        } else e = document.createElement(\"input\"), e.type = \"submit\", e.style.display = \"none\", t.appendChild(e), e.click(), t.removeChild(e);\n      }\n\n      function s(t) {\n        t.disabled = !0;\n      }\n\n      function f(t) {\n        t.disabled = !1;\n      }\n\n      e.a = n;\n      var c = r(4),\n          h = r(0),\n          l = \"data-direct-uploads-processing\",\n          d = !1;\n    }, function (t, e, r) {\n      function n(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      r.d(e, \"a\", function () {\n        return s;\n      });\n\n      var i = r(5),\n          a = r(0),\n          u = function () {\n        function t(t, e) {\n          for (var r = 0; r < e.length; r++) {\n            var n = e[r];\n            n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n          }\n        }\n\n        return function (e, r, n) {\n          return r && t(e.prototype, r), n && t(e, n), e;\n        };\n      }(),\n          o = \"input[type=file][data-direct-upload-url]:not([disabled])\",\n          s = function () {\n        function t(e) {\n          n(this, t), this.form = e, this.inputs = Object(a.c)(e, o).filter(function (t) {\n            return t.files.length;\n          });\n        }\n\n        return u(t, [{\n          key: \"start\",\n          value: function (t) {\n            var e = this,\n                r = this.createDirectUploadControllers();\n            this.dispatch(\"start\"), function n() {\n              var i = r.shift();\n              i ? i.start(function (r) {\n                r ? (t(r), e.dispatch(\"end\")) : n();\n              }) : (t(), e.dispatch(\"end\"));\n            }();\n          }\n        }, {\n          key: \"createDirectUploadControllers\",\n          value: function () {\n            var t = [];\n            return this.inputs.forEach(function (e) {\n              Object(a.e)(e.files).forEach(function (r) {\n                var n = new i.a(e, r);\n                t.push(n);\n              });\n            }), t;\n          }\n        }, {\n          key: \"dispatch\",\n          value: function (t) {\n            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n            return Object(a.a)(this.form, \"direct-uploads:\" + t, {\n              detail: e\n            });\n          }\n        }]), t;\n      }();\n    }, function (t, e, r) {\n      function n(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      r.d(e, \"a\", function () {\n        return o;\n      });\n\n      var i = r(1),\n          a = r(0),\n          u = function () {\n        function t(t, e) {\n          for (var r = 0; r < e.length; r++) {\n            var n = e[r];\n            n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n          }\n        }\n\n        return function (e, r, n) {\n          return r && t(e.prototype, r), n && t(e, n), e;\n        };\n      }(),\n          o = function () {\n        function t(e, r) {\n          n(this, t), this.input = e, this.file = r, this.directUpload = new i.a(this.file, this.url, this), this.dispatch(\"initialize\");\n        }\n\n        return u(t, [{\n          key: \"start\",\n          value: function (t) {\n            var e = this,\n                r = document.createElement(\"input\");\n            r.type = \"hidden\", r.name = this.input.name, this.input.insertAdjacentElement(\"beforebegin\", r), this.dispatch(\"start\"), this.directUpload.create(function (n, i) {\n              n ? (r.parentNode.removeChild(r), e.dispatchError(n)) : r.value = i.signed_id, e.dispatch(\"end\"), t(n);\n            });\n          }\n        }, {\n          key: \"uploadRequestDidProgress\",\n          value: function (t) {\n            var e = t.loaded / t.total * 100;\n            e && this.dispatch(\"progress\", {\n              progress: e\n            });\n          }\n        }, {\n          key: \"dispatch\",\n          value: function (t) {\n            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n            return e.file = this.file, e.id = this.directUpload.id, Object(a.a)(this.input, \"direct-upload:\" + t, {\n              detail: e\n            });\n          }\n        }, {\n          key: \"dispatchError\",\n          value: function (t) {\n            this.dispatch(\"error\", {\n              error: t\n            }).defaultPrevented || alert(t);\n          }\n        }, {\n          key: \"directUploadWillCreateBlobWithXHR\",\n          value: function (t) {\n            this.dispatch(\"before-blob-request\", {\n              xhr: t\n            });\n          }\n        }, {\n          key: \"directUploadWillStoreFileWithXHR\",\n          value: function (t) {\n            var e = this;\n            this.dispatch(\"before-storage-request\", {\n              xhr: t\n            }), t.upload.addEventListener(\"progress\", function (t) {\n              return e.uploadRequestDidProgress(t);\n            });\n          }\n        }, {\n          key: \"url\",\n          get: function () {\n            return this.input.getAttribute(\"data-direct-upload-url\");\n          }\n        }]), t;\n      }();\n    }, function (t, e, r) {\n      function n(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      r.d(e, \"a\", function () {\n        return s;\n      });\n\n      var i = r(7),\n          a = r.n(i),\n          u = function () {\n        function t(t, e) {\n          for (var r = 0; r < e.length; r++) {\n            var n = e[r];\n            n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n          }\n        }\n\n        return function (e, r, n) {\n          return r && t(e.prototype, r), n && t(e, n), e;\n        };\n      }(),\n          o = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,\n          s = function () {\n        function t(e) {\n          n(this, t), this.file = e, this.chunkSize = 2097152, this.chunkCount = Math.ceil(this.file.size / this.chunkSize), this.chunkIndex = 0;\n        }\n\n        return u(t, null, [{\n          key: \"create\",\n          value: function (e, r) {\n            new t(e).create(r);\n          }\n        }]), u(t, [{\n          key: \"create\",\n          value: function (t) {\n            var e = this;\n            this.callback = t, this.md5Buffer = new a.a.ArrayBuffer(), this.fileReader = new FileReader(), this.fileReader.addEventListener(\"load\", function (t) {\n              return e.fileReaderDidLoad(t);\n            }), this.fileReader.addEventListener(\"error\", function (t) {\n              return e.fileReaderDidError(t);\n            }), this.readNextChunk();\n          }\n        }, {\n          key: \"fileReaderDidLoad\",\n          value: function (t) {\n            if (this.md5Buffer.append(t.target.result), !this.readNextChunk()) {\n              var e = this.md5Buffer.end(!0),\n                  r = btoa(e);\n              this.callback(null, r);\n            }\n          }\n        }, {\n          key: \"fileReaderDidError\",\n          value: function (t) {\n            this.callback(\"Error reading \" + this.file.name);\n          }\n        }, {\n          key: \"readNextChunk\",\n          value: function () {\n            if (this.chunkIndex < this.chunkCount || 0 == this.chunkIndex && 0 == this.chunkCount) {\n              var t = this.chunkIndex * this.chunkSize,\n                  e = Math.min(t + this.chunkSize, this.file.size),\n                  r = o.call(this.file, t, e);\n              return this.fileReader.readAsArrayBuffer(r), this.chunkIndex++, !0;\n            }\n\n            return !1;\n          }\n        }]), t;\n      }();\n    }, function (t, e, r) {\n      !function (e) {\n        t.exports = e();\n      }(function (t) {\n        function e(t, e) {\n          var r = t[0],\n              n = t[1],\n              i = t[2],\n              a = t[3];\n          r += (n & i | ~n & a) + e[0] - 680876936 | 0, r = (r << 7 | r >>> 25) + n | 0, a += (r & n | ~r & i) + e[1] - 389564586 | 0, a = (a << 12 | a >>> 20) + r | 0, i += (a & r | ~a & n) + e[2] + 606105819 | 0, i = (i << 17 | i >>> 15) + a | 0, n += (i & a | ~i & r) + e[3] - 1044525330 | 0, n = (n << 22 | n >>> 10) + i | 0, r += (n & i | ~n & a) + e[4] - 176418897 | 0, r = (r << 7 | r >>> 25) + n | 0, a += (r & n | ~r & i) + e[5] + 1200080426 | 0, a = (a << 12 | a >>> 20) + r | 0, i += (a & r | ~a & n) + e[6] - 1473231341 | 0, i = (i << 17 | i >>> 15) + a | 0, n += (i & a | ~i & r) + e[7] - 45705983 | 0, n = (n << 22 | n >>> 10) + i | 0, r += (n & i | ~n & a) + e[8] + 1770035416 | 0, r = (r << 7 | r >>> 25) + n | 0, a += (r & n | ~r & i) + e[9] - 1958414417 | 0, a = (a << 12 | a >>> 20) + r | 0, i += (a & r | ~a & n) + e[10] - 42063 | 0, i = (i << 17 | i >>> 15) + a | 0, n += (i & a | ~i & r) + e[11] - 1990404162 | 0, n = (n << 22 | n >>> 10) + i | 0, r += (n & i | ~n & a) + e[12] + 1804603682 | 0, r = (r << 7 | r >>> 25) + n | 0, a += (r & n | ~r & i) + e[13] - 40341101 | 0, a = (a << 12 | a >>> 20) + r | 0, i += (a & r | ~a & n) + e[14] - 1502002290 | 0, i = (i << 17 | i >>> 15) + a | 0, n += (i & a | ~i & r) + e[15] + 1236535329 | 0, n = (n << 22 | n >>> 10) + i | 0, r += (n & a | i & ~a) + e[1] - 165796510 | 0, r = (r << 5 | r >>> 27) + n | 0, a += (r & i | n & ~i) + e[6] - 1069501632 | 0, a = (a << 9 | a >>> 23) + r | 0, i += (a & n | r & ~n) + e[11] + 643717713 | 0, i = (i << 14 | i >>> 18) + a | 0, n += (i & r | a & ~r) + e[0] - 373897302 | 0, n = (n << 20 | n >>> 12) + i | 0, r += (n & a | i & ~a) + e[5] - 701558691 | 0, r = (r << 5 | r >>> 27) + n | 0, a += (r & i | n & ~i) + e[10] + 38016083 | 0, a = (a << 9 | a >>> 23) + r | 0, i += (a & n | r & ~n) + e[15] - 660478335 | 0, i = (i << 14 | i >>> 18) + a | 0, n += (i & r | a & ~r) + e[4] - 405537848 | 0, n = (n << 20 | n >>> 12) + i | 0, r += (n & a | i & ~a) + e[9] + 568446438 | 0, r = (r << 5 | r >>> 27) + n | 0, a += (r & i | n & ~i) + e[14] - 1019803690 | 0, a = (a << 9 | a >>> 23) + r | 0, i += (a & n | r & ~n) + e[3] - 187363961 | 0, i = (i << 14 | i >>> 18) + a | 0, n += (i & r | a & ~r) + e[8] + 1163531501 | 0, n = (n << 20 | n >>> 12) + i | 0, r += (n & a | i & ~a) + e[13] - 1444681467 | 0, r = (r << 5 | r >>> 27) + n | 0, a += (r & i | n & ~i) + e[2] - 51403784 | 0, a = (a << 9 | a >>> 23) + r | 0, i += (a & n | r & ~n) + e[7] + 1735328473 | 0, i = (i << 14 | i >>> 18) + a | 0, n += (i & r | a & ~r) + e[12] - 1926607734 | 0, n = (n << 20 | n >>> 12) + i | 0, r += (n ^ i ^ a) + e[5] - 378558 | 0, r = (r << 4 | r >>> 28) + n | 0, a += (r ^ n ^ i) + e[8] - 2022574463 | 0, a = (a << 11 | a >>> 21) + r | 0, i += (a ^ r ^ n) + e[11] + 1839030562 | 0, i = (i << 16 | i >>> 16) + a | 0, n += (i ^ a ^ r) + e[14] - 35309556 | 0, n = (n << 23 | n >>> 9) + i | 0, r += (n ^ i ^ a) + e[1] - 1530992060 | 0, r = (r << 4 | r >>> 28) + n | 0, a += (r ^ n ^ i) + e[4] + 1272893353 | 0, a = (a << 11 | a >>> 21) + r | 0, i += (a ^ r ^ n) + e[7] - 155497632 | 0, i = (i << 16 | i >>> 16) + a | 0, n += (i ^ a ^ r) + e[10] - 1094730640 | 0, n = (n << 23 | n >>> 9) + i | 0, r += (n ^ i ^ a) + e[13] + 681279174 | 0, r = (r << 4 | r >>> 28) + n | 0, a += (r ^ n ^ i) + e[0] - 358537222 | 0, a = (a << 11 | a >>> 21) + r | 0, i += (a ^ r ^ n) + e[3] - 722521979 | 0, i = (i << 16 | i >>> 16) + a | 0, n += (i ^ a ^ r) + e[6] + 76029189 | 0, n = (n << 23 | n >>> 9) + i | 0, r += (n ^ i ^ a) + e[9] - 640364487 | 0, r = (r << 4 | r >>> 28) + n | 0, a += (r ^ n ^ i) + e[12] - 421815835 | 0, a = (a << 11 | a >>> 21) + r | 0, i += (a ^ r ^ n) + e[15] + 530742520 | 0, i = (i << 16 | i >>> 16) + a | 0, n += (i ^ a ^ r) + e[2] - 995338651 | 0, n = (n << 23 | n >>> 9) + i | 0, r += (i ^ (n | ~a)) + e[0] - 198630844 | 0, r = (r << 6 | r >>> 26) + n | 0, a += (n ^ (r | ~i)) + e[7] + 1126891415 | 0, a = (a << 10 | a >>> 22) + r | 0, i += (r ^ (a | ~n)) + e[14] - 1416354905 | 0, i = (i << 15 | i >>> 17) + a | 0, n += (a ^ (i | ~r)) + e[5] - 57434055 | 0, n = (n << 21 | n >>> 11) + i | 0, r += (i ^ (n | ~a)) + e[12] + 1700485571 | 0, r = (r << 6 | r >>> 26) + n | 0, a += (n ^ (r | ~i)) + e[3] - 1894986606 | 0, a = (a << 10 | a >>> 22) + r | 0, i += (r ^ (a | ~n)) + e[10] - 1051523 | 0, i = (i << 15 | i >>> 17) + a | 0, n += (a ^ (i | ~r)) + e[1] - 2054922799 | 0, n = (n << 21 | n >>> 11) + i | 0, r += (i ^ (n | ~a)) + e[8] + 1873313359 | 0, r = (r << 6 | r >>> 26) + n | 0, a += (n ^ (r | ~i)) + e[15] - 30611744 | 0, a = (a << 10 | a >>> 22) + r | 0, i += (r ^ (a | ~n)) + e[6] - 1560198380 | 0, i = (i << 15 | i >>> 17) + a | 0, n += (a ^ (i | ~r)) + e[13] + 1309151649 | 0, n = (n << 21 | n >>> 11) + i | 0, r += (i ^ (n | ~a)) + e[4] - 145523070 | 0, r = (r << 6 | r >>> 26) + n | 0, a += (n ^ (r | ~i)) + e[11] - 1120210379 | 0, a = (a << 10 | a >>> 22) + r | 0, i += (r ^ (a | ~n)) + e[2] + 718787259 | 0, i = (i << 15 | i >>> 17) + a | 0, n += (a ^ (i | ~r)) + e[9] - 343485551 | 0, n = (n << 21 | n >>> 11) + i | 0, t[0] = r + t[0] | 0, t[1] = n + t[1] | 0, t[2] = i + t[2] | 0, t[3] = a + t[3] | 0;\n        }\n\n        function r(t) {\n          var e,\n              r = [];\n\n          for (e = 0; e < 64; e += 4) r[e >> 2] = t.charCodeAt(e) + (t.charCodeAt(e + 1) << 8) + (t.charCodeAt(e + 2) << 16) + (t.charCodeAt(e + 3) << 24);\n\n          return r;\n        }\n\n        function n(t) {\n          var e,\n              r = [];\n\n          for (e = 0; e < 64; e += 4) r[e >> 2] = t[e] + (t[e + 1] << 8) + (t[e + 2] << 16) + (t[e + 3] << 24);\n\n          return r;\n        }\n\n        function i(t) {\n          var n,\n              i,\n              a,\n              u,\n              o,\n              s,\n              f = t.length,\n              c = [1732584193, -271733879, -1732584194, 271733878];\n\n          for (n = 64; n <= f; n += 64) e(c, r(t.substring(n - 64, n)));\n\n          for (t = t.substring(n - 64), i = t.length, a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n = 0; n < i; n += 1) a[n >> 2] |= t.charCodeAt(n) << (n % 4 << 3);\n\n          if (a[n >> 2] |= 128 << (n % 4 << 3), n > 55) for (e(c, a), n = 0; n < 16; n += 1) a[n] = 0;\n          return u = 8 * f, u = u.toString(16).match(/(.*?)(.{0,8})$/), o = parseInt(u[2], 16), s = parseInt(u[1], 16) || 0, a[14] = o, a[15] = s, e(c, a), c;\n        }\n\n        function a(t) {\n          var r,\n              i,\n              a,\n              u,\n              o,\n              s,\n              f = t.length,\n              c = [1732584193, -271733879, -1732584194, 271733878];\n\n          for (r = 64; r <= f; r += 64) e(c, n(t.subarray(r - 64, r)));\n\n          for (t = r - 64 < f ? t.subarray(r - 64) : new Uint8Array(0), i = t.length, a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], r = 0; r < i; r += 1) a[r >> 2] |= t[r] << (r % 4 << 3);\n\n          if (a[r >> 2] |= 128 << (r % 4 << 3), r > 55) for (e(c, a), r = 0; r < 16; r += 1) a[r] = 0;\n          return u = 8 * f, u = u.toString(16).match(/(.*?)(.{0,8})$/), o = parseInt(u[2], 16), s = parseInt(u[1], 16) || 0, a[14] = o, a[15] = s, e(c, a), c;\n        }\n\n        function u(t) {\n          var e,\n              r = \"\";\n\n          for (e = 0; e < 4; e += 1) r += p[t >> 8 * e + 4 & 15] + p[t >> 8 * e & 15];\n\n          return r;\n        }\n\n        function o(t) {\n          var e;\n\n          for (e = 0; e < t.length; e += 1) t[e] = u(t[e]);\n\n          return t.join(\"\");\n        }\n\n        function s(t) {\n          return /[\\u0080-\\uFFFF]/.test(t) && (t = unescape(encodeURIComponent(t))), t;\n        }\n\n        function f(t, e) {\n          var r,\n              n = t.length,\n              i = new ArrayBuffer(n),\n              a = new Uint8Array(i);\n\n          for (r = 0; r < n; r += 1) a[r] = t.charCodeAt(r);\n\n          return e ? a : i;\n        }\n\n        function c(t) {\n          return String.fromCharCode.apply(null, new Uint8Array(t));\n        }\n\n        function h(t, e, r) {\n          var n = new Uint8Array(t.byteLength + e.byteLength);\n          return n.set(new Uint8Array(t)), n.set(new Uint8Array(e), t.byteLength), r ? n : n.buffer;\n        }\n\n        function l(t) {\n          var e,\n              r = [],\n              n = t.length;\n\n          for (e = 0; e < n - 1; e += 2) r.push(parseInt(t.substr(e, 2), 16));\n\n          return String.fromCharCode.apply(String, r);\n        }\n\n        function d() {\n          this.reset();\n        }\n\n        var p = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n        return \"5d41402abc4b2a76b9719d911017c592\" !== o(i(\"hello\")) && function (t, e) {\n          var r = (65535 & t) + (65535 & e);\n          return (t >> 16) + (e >> 16) + (r >> 16) << 16 | 65535 & r;\n        }, \"undefined\" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || function () {\n          function e(t, e) {\n            return t = 0 | t || 0, t < 0 ? Math.max(t + e, 0) : Math.min(t, e);\n          }\n\n          ArrayBuffer.prototype.slice = function (r, n) {\n            var i,\n                a,\n                u,\n                o,\n                s = this.byteLength,\n                f = e(r, s),\n                c = s;\n            return n !== t && (c = e(n, s)), f > c ? new ArrayBuffer(0) : (i = c - f, a = new ArrayBuffer(i), u = new Uint8Array(a), o = new Uint8Array(this, f, i), u.set(o), a);\n          };\n        }(), d.prototype.append = function (t) {\n          return this.appendBinary(s(t)), this;\n        }, d.prototype.appendBinary = function (t) {\n          this._buff += t, this._length += t.length;\n          var n,\n              i = this._buff.length;\n\n          for (n = 64; n <= i; n += 64) e(this._hash, r(this._buff.substring(n - 64, n)));\n\n          return this._buff = this._buff.substring(n - 64), this;\n        }, d.prototype.end = function (t) {\n          var e,\n              r,\n              n = this._buff,\n              i = n.length,\n              a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n          for (e = 0; e < i; e += 1) a[e >> 2] |= n.charCodeAt(e) << (e % 4 << 3);\n\n          return this._finish(a, i), r = o(this._hash), t && (r = l(r)), this.reset(), r;\n        }, d.prototype.reset = function () {\n          return this._buff = \"\", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;\n        }, d.prototype.getState = function () {\n          return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n          };\n        }, d.prototype.setState = function (t) {\n          return this._buff = t.buff, this._length = t.length, this._hash = t.hash, this;\n        }, d.prototype.destroy = function () {\n          delete this._hash, delete this._buff, delete this._length;\n        }, d.prototype._finish = function (t, r) {\n          var n,\n              i,\n              a,\n              u = r;\n          if (t[u >> 2] |= 128 << (u % 4 << 3), u > 55) for (e(this._hash, t), u = 0; u < 16; u += 1) t[u] = 0;\n          n = 8 * this._length, n = n.toString(16).match(/(.*?)(.{0,8})$/), i = parseInt(n[2], 16), a = parseInt(n[1], 16) || 0, t[14] = i, t[15] = a, e(this._hash, t);\n        }, d.hash = function (t, e) {\n          return d.hashBinary(s(t), e);\n        }, d.hashBinary = function (t, e) {\n          var r = i(t),\n              n = o(r);\n          return e ? l(n) : n;\n        }, d.ArrayBuffer = function () {\n          this.reset();\n        }, d.ArrayBuffer.prototype.append = function (t) {\n          var r,\n              i = h(this._buff.buffer, t, !0),\n              a = i.length;\n\n          for (this._length += t.byteLength, r = 64; r <= a; r += 64) e(this._hash, n(i.subarray(r - 64, r)));\n\n          return this._buff = r - 64 < a ? new Uint8Array(i.buffer.slice(r - 64)) : new Uint8Array(0), this;\n        }, d.ArrayBuffer.prototype.end = function (t) {\n          var e,\n              r,\n              n = this._buff,\n              i = n.length,\n              a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n          for (e = 0; e < i; e += 1) a[e >> 2] |= n[e] << (e % 4 << 3);\n\n          return this._finish(a, i), r = o(this._hash), t && (r = l(r)), this.reset(), r;\n        }, d.ArrayBuffer.prototype.reset = function () {\n          return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;\n        }, d.ArrayBuffer.prototype.getState = function () {\n          var t = d.prototype.getState.call(this);\n          return t.buff = c(t.buff), t;\n        }, d.ArrayBuffer.prototype.setState = function (t) {\n          return t.buff = f(t.buff, !0), d.prototype.setState.call(this, t);\n        }, d.ArrayBuffer.prototype.destroy = d.prototype.destroy, d.ArrayBuffer.prototype._finish = d.prototype._finish, d.ArrayBuffer.hash = function (t, e) {\n          var r = a(new Uint8Array(t)),\n              n = o(r);\n          return e ? l(n) : n;\n        }, d;\n      });\n    }, function (t, e, r) {\n      function n(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      r.d(e, \"a\", function () {\n        return u;\n      });\n\n      var i = r(0),\n          a = function () {\n        function t(t, e) {\n          for (var r = 0; r < e.length; r++) {\n            var n = e[r];\n            n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n          }\n        }\n\n        return function (e, r, n) {\n          return r && t(e.prototype, r), n && t(e, n), e;\n        };\n      }(),\n          u = function () {\n        function t(e, r, a) {\n          var u = this;\n          n(this, t), this.file = e, this.attributes = {\n            filename: e.name,\n            content_type: e.type,\n            byte_size: e.size,\n            checksum: r\n          }, this.xhr = new XMLHttpRequest(), this.xhr.open(\"POST\", a, !0), this.xhr.responseType = \"json\", this.xhr.setRequestHeader(\"Content-Type\", \"application/json\"), this.xhr.setRequestHeader(\"Accept\", \"application/json\"), this.xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), this.xhr.setRequestHeader(\"X-CSRF-Token\", Object(i.d)(\"csrf-token\")), this.xhr.addEventListener(\"load\", function (t) {\n            return u.requestDidLoad(t);\n          }), this.xhr.addEventListener(\"error\", function (t) {\n            return u.requestDidError(t);\n          });\n        }\n\n        return a(t, [{\n          key: \"create\",\n          value: function (t) {\n            this.callback = t, this.xhr.send(JSON.stringify({\n              blob: this.attributes\n            }));\n          }\n        }, {\n          key: \"requestDidLoad\",\n          value: function (t) {\n            if (this.status >= 200 && this.status < 300) {\n              var e = this.response,\n                  r = e.direct_upload;\n              delete e.direct_upload, this.attributes = e, this.directUploadData = r, this.callback(null, this.toJSON());\n            } else this.requestDidError(t);\n          }\n        }, {\n          key: \"requestDidError\",\n          value: function (t) {\n            this.callback('Error creating Blob for \"' + this.file.name + '\". Status: ' + this.status);\n          }\n        }, {\n          key: \"toJSON\",\n          value: function () {\n            var t = {};\n\n            for (var e in this.attributes) t[e] = this.attributes[e];\n\n            return t;\n          }\n        }, {\n          key: \"status\",\n          get: function () {\n            return this.xhr.status;\n          }\n        }, {\n          key: \"response\",\n          get: function () {\n            var t = this.xhr,\n                e = t.responseType,\n                r = t.response;\n            return \"json\" == e ? r : JSON.parse(r);\n          }\n        }]), t;\n      }();\n    }, function (t, e, r) {\n      function n(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      r.d(e, \"a\", function () {\n        return a;\n      });\n\n      var i = function () {\n        function t(t, e) {\n          for (var r = 0; r < e.length; r++) {\n            var n = e[r];\n            n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n          }\n        }\n\n        return function (e, r, n) {\n          return r && t(e.prototype, r), n && t(e, n), e;\n        };\n      }(),\n          a = function () {\n        function t(e) {\n          var r = this;\n          n(this, t), this.blob = e, this.file = e.file;\n          var i = e.directUploadData,\n              a = i.url,\n              u = i.headers;\n          this.xhr = new XMLHttpRequest(), this.xhr.open(\"PUT\", a, !0), this.xhr.responseType = \"text\";\n\n          for (var o in u) this.xhr.setRequestHeader(o, u[o]);\n\n          this.xhr.addEventListener(\"load\", function (t) {\n            return r.requestDidLoad(t);\n          }), this.xhr.addEventListener(\"error\", function (t) {\n            return r.requestDidError(t);\n          });\n        }\n\n        return i(t, [{\n          key: \"create\",\n          value: function (t) {\n            this.callback = t, this.xhr.send(this.file.slice());\n          }\n        }, {\n          key: \"requestDidLoad\",\n          value: function (t) {\n            var e = this.xhr,\n                r = e.status,\n                n = e.response;\n            r >= 200 && r < 300 ? this.callback(null, n) : this.requestDidError(t);\n          }\n        }, {\n          key: \"requestDidError\",\n          value: function (t) {\n            this.callback('Error storing \"' + this.file.name + '\". Status: ' + this.xhr.status);\n          }\n        }]), t;\n      }();\n    }]);\n  });\n});\nunwrapExports(activestorage);\nvar activestorage_1 = activestorage.start;\nvar activestorage_2 = activestorage.DirectUpload;\nvar activestorage_3 = activestorage.ActiveStorage;\n\nfunction compactObject(obj) {\n  var newObj = objectSpread({}, obj);\n  Object.keys(newObj).forEach(function (key) {\n    return newObj[key] === undefined && delete newObj[key];\n  });\n  return newObj;\n}\n\nvar Upload =\n/*#__PURE__*/\nfunction () {\n  function Upload(file, options) {\n    var _this = this;\n\n    classCallCheck(this, Upload);\n    defineProperty(this, \"directUpload\", void 0);\n    defineProperty(this, \"options\", void 0);\n    defineProperty(this, \"handleChangeFile\", function (upload) {\n      _this.options.onChangeFile(defineProperty({}, _this.id, upload));\n    });\n    defineProperty(this, \"handleProgress\", function (_ref) {\n      var loaded = _ref.loaded,\n          total = _ref.total;\n      var progress = loaded / total * 100;\n\n      _this.handleChangeFile({\n        state: 'uploading',\n        file: _this.directUpload.file,\n        id: _this.id,\n        progress: progress\n      });\n    });\n    defineProperty(this, \"handleSuccess\", function (signedId) {\n      _this.handleChangeFile({\n        state: 'finished',\n        id: _this.id,\n        file: _this.directUpload.file\n      });\n\n      return signedId;\n    });\n    defineProperty(this, \"handleError\", function (error) {\n      _this.handleChangeFile({\n        state: 'error',\n        id: _this.id,\n        file: _this.directUpload.file,\n        error: error\n      });\n\n      throw error;\n    });\n    this.options = objectSpread({}, Upload.defaultOptions, compactObject(options));\n    this.directUpload = new activestorage_2(file, this.directUploadsUrl, this);\n    this.handleChangeFile({\n      state: 'waiting',\n      id: this.id,\n      file: file\n    });\n  }\n\n  createClass(Upload, [{\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      var promise = new Promise(function (resolve, reject) {\n        _this2.directUpload.create(function (error, attributes) {\n          if (error) reject(error);else resolve(attributes.signed_id);\n        });\n      });\n      return promise.then(this.handleSuccess).catch(this.handleError);\n    }\n    /**\n     * DirectUpload delegate protocol conformance\n     */\n\n  }, {\n    key: \"directUploadWillCreateBlobWithXHR\",\n    value: function directUploadWillCreateBlobWithXHR(xhr) {\n      this.addHeaders(xhr);\n      this.options.onBeforeBlobRequest && this.options.onBeforeBlobRequest({\n        id: this.id,\n        file: this.directUpload.file,\n        xhr: xhr\n      });\n    }\n  }, {\n    key: \"directUploadWillStoreFileWithXHR\",\n    value: function directUploadWillStoreFileWithXHR(xhr) {\n      this.options.onBeforeStorageRequest && this.options.onBeforeStorageRequest({\n        id: this.id,\n        file: this.directUpload.file,\n        xhr: xhr\n      });\n      xhr.upload.addEventListener('progress', this.handleProgress);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"addHeaders\",\n    value: function addHeaders(xhr) {\n      var headers = this.options.headers;\n\n      if (headers) {\n        var _arr = Object.keys(headers);\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var headerKey = _arr[_i];\n          xhr.setRequestHeader(headerKey, headers[headerKey]);\n        }\n      }\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return \"\".concat(this.directUpload.id);\n    }\n  }, {\n    key: \"directUploadsUrl\",\n    get: function get() {\n      var _this$options = this.options,\n          _this$options$origin = _this$options.origin,\n          host = _this$options$origin.host,\n          protocol = _this$options$origin.protocol,\n          port = _this$options$origin.port,\n          directUploadsPath = _this$options.directUploadsPath;\n\n      if (host) {\n        var builtProtocol = protocol ? \"\".concat(protocol.split(':')[0], \"://\") : 'https://';\n        var builtPort = port ? \":\".concat(port) : '';\n        return \"\".concat(builtProtocol).concat(host).concat(builtPort).concat(directUploadsPath);\n      }\n\n      return directUploadsPath;\n    }\n  }]);\n  return Upload;\n}();\n\ndefineProperty(Upload, \"CONVENTIONAL_DIRECT_UPLOADS_PATH\", '/rails/active_storage/direct_uploads');\ndefineProperty(Upload, \"defaultOptions\", {\n  origin: {},\n  directUploadsPath: Upload.CONVENTIONAL_DIRECT_UPLOADS_PATH\n});\n\nvar DirectUploadProvider =\n/*#__PURE__*/\nfunction (_React$Component) {\n  inherits(DirectUploadProvider, _React$Component);\n\n  function DirectUploadProvider() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    classCallCheck(this, DirectUploadProvider);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf(DirectUploadProvider)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"state\", {\n      uploading: false,\n      fileUploads: {}\n    });\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"uploads\", []);\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"handleUpload\",\n    /*#__PURE__*/\n    function () {\n      var _ref = asyncToGenerator(\n      /*#__PURE__*/\n      regenerator.mark(function _callee(files) {\n        return regenerator.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this.handleChooseFiles(files);\n\n                return _context.abrupt(\"return\", _this.handleBeginUpload());\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"handleChooseFiles\", function (files) {\n      if (_this.state.uploading) return;\n\n      _this.setState({\n        fileUploads: {}\n      });\n\n      _this.uploads = toConsumableArray(files).map(function (file) {\n        return _this._createUpload(file);\n      });\n    });\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"handleBeginUpload\",\n    /*#__PURE__*/\n    asyncToGenerator(\n    /*#__PURE__*/\n    regenerator.mark(function _callee2() {\n      var signedIds;\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!_this.state.uploading) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              _this.setState({\n                uploading: true\n              });\n\n              _context2.next = 5;\n              return Promise.all(_this.uploads.map(function (upload) {\n                return upload.start();\n              }));\n\n            case 5:\n              signedIds = _context2.sent;\n\n              _this.props.onSuccess(signedIds);\n\n              _this.uploads = [];\n\n              _this.setState({\n                fileUploads: {},\n                uploading: false\n              });\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    })));\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"handleChangeFileUpload\", function (fileUpload) {\n      return _this.setState(function (_ref3) {\n        var fileUploads = _ref3.fileUploads;\n        return {\n          fileUploads: objectSpread({}, fileUploads, fileUpload)\n        };\n      });\n    });\n    return _this;\n  }\n\n  createClass(DirectUploadProvider, [{\n    key: \"render\",\n    value: function render() {\n      var fileUploads = this.state.fileUploads;\n      return this.props.render({\n        handleChooseFiles: this.handleChooseFiles,\n        handleBeginUpload: this.handleBeginUpload,\n        handleUpload: this.handleUpload,\n        ready: !this.state.uploading,\n        uploads: Object.keys(fileUploads).map(function (key) {\n          return fileUploads[key];\n        })\n      });\n    }\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload(file) {\n      var _this$props = this.props,\n          directUploadsPath = _this$props.directUploadsPath,\n          headers = _this$props.headers,\n          onBeforeBlobRequest = _this$props.onBeforeBlobRequest,\n          onBeforeStorageRequest = _this$props.onBeforeStorageRequest,\n          origin = _this$props.origin;\n      return new Upload(file, {\n        directUploadsPath: directUploadsPath,\n        headers: headers,\n        onBeforeBlobRequest: onBeforeBlobRequest,\n        onBeforeStorageRequest: onBeforeStorageRequest,\n        onChangeFile: this.handleChangeFileUpload,\n        origin: origin\n      });\n    }\n  }]);\n  return DirectUploadProvider;\n}(Component);\n\ndefineProperty(DirectUploadProvider, \"defaultProps\", {\n  origin: {}\n});\n/**\n * Extract the CSRF token from the <%= csrf_meta_tags %>\n *\n * @providesModule csrfHeader\n * \n */\n\nfunction getToken() {\n  var meta = document.querySelector(\"meta[name=\\\"csrf-token\\\"]\");\n  return meta && meta.getAttribute('content');\n}\n\nfunction csrfHeader() {\n  var token = getToken();\n  return token ? {\n    'x-csrf-token': token\n  } : {};\n}\n\nvar ActiveStorageProvider =\n/*#__PURE__*/\nfunction (_React$Component) {\n  inherits(ActiveStorageProvider, _React$Component);\n\n  function ActiveStorageProvider() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    classCallCheck(this, ActiveStorageProvider);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf(ActiveStorageProvider)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    defineProperty(assertThisInitialized(assertThisInitialized(_this)), \"handleSuccess\",\n    /*#__PURE__*/\n    function () {\n      var _ref = asyncToGenerator(\n      /*#__PURE__*/\n      regenerator.mark(function _callee(ids) {\n        var data;\n        return regenerator.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(ids.length === 0)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.prev = 2;\n                _context.next = 5;\n                return _this._hitEndpointWithSignedIds(ids);\n\n              case 5:\n                data = _context.sent;\n\n                _this.props.onSubmit(data);\n\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](2);\n                _this.props.onError && _this.props.onError(_context.t0);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 9]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    return _this;\n  }\n\n  createClass(ActiveStorageProvider, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          _this$props$endpoint = _this$props.endpoint,\n          host = _this$props$endpoint.host,\n          port = _this$props$endpoint.port,\n          protocol = _this$props$endpoint.protocol,\n          onSubmit = _this$props.onSubmit,\n          props = objectWithoutProperties(_this$props, [\"endpoint\", \"onSubmit\"]);\n      return createElement(DirectUploadProvider, _extends_1({}, props, {\n        origin: {\n          host: host,\n          port: port,\n          protocol: protocol\n        },\n        onSuccess: this.handleSuccess\n      }));\n    }\n  }, {\n    key: \"_hitEndpointWithSignedIds\",\n    value: function () {\n      var _hitEndpointWithSignedIds2 = asyncToGenerator(\n      /*#__PURE__*/\n      regenerator.mark(function _callee2(signedIds) {\n        var _this$props2, endpoint, multiple, path, method, attribute, model, body, response;\n\n        return regenerator.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this$props2 = this.props, endpoint = _this$props2.endpoint, multiple = _this$props2.multiple;\n                path = endpoint.path, method = endpoint.method, attribute = endpoint.attribute, model = endpoint.model;\n                body = defineProperty({}, model.toLowerCase(), defineProperty({}, attribute, multiple ? signedIds : signedIds[0]));\n                _context2.next = 5;\n                return fetch(path, {\n                  credentials: 'same-origin',\n                  method: method,\n                  body: JSON.stringify(body),\n                  headers: this._headers\n                });\n\n              case 5:\n                response = _context2.sent;\n\n                if (response.ok) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw response;\n\n              case 8:\n                return _context2.abrupt(\"return\", response.json());\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function _hitEndpointWithSignedIds(_x2) {\n        return _hitEndpointWithSignedIds2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_headers\",\n    get: function get() {\n      var headers = this.props.headers;\n      var normalizedHeaders = Object.keys(headers).reduce(function (acc, key) {\n        acc[key.toLowerCase()] = headers[key];\n        return acc;\n      }, {});\n      return new Headers(objectSpread({\n        accept: 'application/json',\n        'content-type': 'application/json'\n      }, csrfHeader(), normalizedHeaders));\n    }\n  }]);\n  return ActiveStorageProvider;\n}(Component);\n\ndefineProperty(ActiveStorageProvider, \"defaultProps\", {\n  headers: {}\n});\nexport default ActiveStorageProvider;\nexport { DirectUploadProvider };","map":null,"metadata":{},"sourceType":"module"}